---
title: "**Poisson and Negative Binomial Simulations**"
output: html_document
date: '2024-07-24'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# **Simulation Details**

We simulate a matrix $Y \in \mathbb{R}^{n\times p}$ that contains raw expression values (scRNA-seq counts) for $p$ genes and $n$ single cells. We set $\pi$ as the percent of genes that are overdispersed. We use a Gamma-Poisson model for each gene and can set the dispersion level for each simulated gene.

```{r, eval=F,include=F}
## **Poisson Distribution**

### ***Model***

We first simulate a Poisson distribution as our null model for each gene, where there is no dispersion parameter.

$$
y_{ij} \sim Pois(L_i\lambda_j) 
$$

Where the variables for cell $i$ and gene $j$ are:

-   $y_{ij}$ is the number of unique molecular identifier (UMI) for cell $i$ and gene $j$

-   $L_i$ is the library size of cell $i$

-   $\lambda_j$ is the relative expression value of gene $j$

### ***Density Function***

The density function for the Poisson distribution is:

$$
f(y;\lambda) = \frac{\lambda^y e^{-\lambda}}{y!}
$$

Where for $y =0,1,2,...$ the $E[Y] = Var[Y] = \lambda$.

### ***Simulation Parameters***

We use the **rpois(**$n$, $\lambda$) function in R to simulate the Poisson distribution. The library size and relative expression values are calculated from a real data set (human-chimp hybrid data). Each $Y$ is calculated for cells from the same species, cell type, and replicate. We simulate for $n=500$ cells.
```

## **Gamma-Poisson (NB) Distribution**

### ***Model***

We simulate the Negative Binomial distribution using the Gamma-Poisson distribution, since the Gamma distribution is a conjugate prior of the Poisson distribution. The mean is fixed for each bin of mean expression. The dispersion parameter differs from the background versus the dispersed gene. Under this model,

$$
y_{ij} \sim Pois(L_i \lambda_{ij})
$$

$$
\lambda_{ij} \sim \begin{equation}
  f_j(\cdot) =
    \begin{cases}
      Gamma(\mu_{j},\phi_{j_0}) & \text{for background gene} \\
      Gamma(\mu_j,\phi_j) & \text{for overdispersed gene} \\
    \end{cases}       
\end{equation}
$$

Where the variables for cell $i$ and gene $j$ are:

-   $y_{ij}$ is the number of unique molecular identifier (UMI) for cell $i$ and gene $j$

-   $L_i$ is the library size of cell $i$

-   $\lambda_{ij}$ is the latent expression value of gene $j$

-   $\mu_j$ is the mean relative expression value of $\lambda_{ij}$ for gene $j$

-   $\phi_j$ is the dispersion value of $\lambda_{ij}$ for gene $j$

-   $\phi_{j_0}$ is the null dispersion value for a background gene

### ***Density Function***

The density function for the Gamma distribution is:

$$
f(y; \mu,\phi) = \frac{(\phi^{-1}\mu^{-1})^{\phi^{-1}}}{\Gamma(\phi^{-1})} y^{\phi^{-1}-1} e^{\phi^{-1}\mu^{-1}y}
$$

Where for $y =0,1,2,...$ the $E[Y] = \mu$ and $Var[Y] = \mu^2 \phi$.

### ***Simulation Parameters***

We will first simulate $\lambda_j$ using the **rgamma(**$n$,$\alpha$,$\sigma$) function in R with mean $\alpha\sigma$ and variance $\alpha\sigma^2$. Thus, $\mu=\alpha\sigma$ and $\phi = 1/\alpha$. We calculate $\mu_j$ for each gene $j$ and $L_i$ for each cell $i$ from the hybrid data set. For genes with dispersion, the $E[f] = \mu_0$. We next simulate the Poisson distribution using the **rpois(**$n$, $\lambda$) function in R. We simulate for $n=500$ cells.

```{r, eval=F,include=F}
## **Negative Binomial Distribution**

We simulate the Negative Binomial distribution as the the alternative model for each gene. The density function is:

$$
f(y;\mu, \theta) = {y+\theta-1 \choose y} \left(\frac{\mu}{\mu+\theta}\right)^y \left(\frac{\theta}{\mu+\theta}\right)^\theta 
$$ where for $y =0,1,2,...$ the $E[Y] = \mu$ and $Var[Y] = \mu + \frac{\mu^2}{\theta}$. Note that the *dispersion* parameter is $\phi=1/\theta$. We use the **rnegbin(**$n$, $\mu$, $\theta$) function from the *MASS* R package to simulate the Negative Binomial distribution.

$$
y_{ij} \sim NB(\mu_j,\theta_j) \text{ ,    where } j = 1,\cdots,p
$$

We set $\mu_j$ equal to the mean gene expression using raw counts from the hybrid data set. Mean gene expression is calculated across cells from the same species, replicate, and cell type. We introduce and test varying dispersion levels for $\phi_j = 1/\theta_j$ and simulate for $n=500$ cells.

```

# **Simulations**

We first calculate the mean gene expression for in the hybrid dataset using Human Cardiomyocytes from Replicate 3. Replicate 3 was chosen since there are 546 cells, which is similar to the 500 cells we will simulate.

```{r, message=F, warning=F}
require(Seurat)
require(SeuratDisk)
require(SeuratData)
library(ggplot2)
library(cowplot)
library(scTenifoldNet)
HC <- LoadH5Seurat("/project2/gilad/awchen55/differentialDispersion/data/hybrid_lines_raw_data/human.ASE.Rep3.h5Seurat")
cardiomyocytes_data <- subset(HC, subset = (labels == "Cardiomyocytes"))
cardiomyocytes_expression_data <- t(cardiomyocytes_data[['RNA']]$counts)
```

We filter for low expression genes and calculate the $L_i$ and relative expression to get $\lambda_j$ values. We target genes that have mean > 0.01 UMI per cell. 

```{r}
# calculate mean expression and remove genes with low expression
cardiomyocytes_expression_data_filtered <- cardiomyocytes_expression_data[, colSums(cardiomyocytes_expression_data != 0) > 10]

# calculate library size
library_sizes <- rowSums(cardiomyocytes_expression_data_filtered)

# calculate mean expression
mean_expression <- colMeans(cardiomyocytes_expression_data_filtered)

# calculate the relative expression for each cell (quantity/rowsum)
relative_expression <- t(apply(cardiomyocytes_expression_data_filtered,1, function(x) x/sum(x)))

# calculate mean relative expression per gene
mean_relative_expression <- colMeans(relative_expression)

# calculate variance relative expression per gene
var_relative_expression <-c()
for(i in 1:length(mean_relative_expression)){
  var_relative_expression <- c(var_relative_expression,var(relative_expression[,i]))
}
```

## **Mean Estimation**

We calculate the sample mean of genes to get an idea of ranges of mean expression. This will inform us of how to bin mean expression.

```{r}
hist(mean_relative_expression, breaks=100)
```

```{r}
hist(mean_expression, breaks=100)
```

```{r}
# get the intervals of relative mean expression
#mean_intervals <- seq(min(mean_relative_expression), max(mean_relative_expression),length.out=101)
mean_intervals <- seq(min(mean_expression), 10,length.out=501)
mean_relative_intervals <- seq(min(mean_relative_expression), 0.01,length.out=501)
```


## **Determine Dispersion Levels**

We simulate a single gene for $n=500$ cells and change the multiplier of the $\sigma$ parameter. Again for the **rgamma** function, the mean is $\alpha\sigma$ and the variance is $\alpha \sigma^2$. Thus, we test different multipliers for sigma to increase the variance in the simulated dispersed genes.

```{r Simulate Gene Function}
# function to simulate a null gene and dispersed gene
sim_gene <- function(n,alpha,sigma,Li, sigma_multiplier=1){

  # Simulate a single gene with following parameters:
  # n:                number of cells
  # alpha:            alpha parameter
  # sigma:            sigma parameter
  # Li:               library size
  # sigma_multiplier: factor to increase variance
 
  # Returns expression values for single gene in n cells
  
  # initialize Y
  Y <- rep(NA,n) 
  
  # calculate latent expression using gamma distribution
  # ensure that simulation has mean within 10% of target
  # perc_diff = 1
  # while(perc_diff > 0.05){
  lambdaj <- rgamma(n,shape = alpha/sigma_multiplier,scale = sigma*sigma_multiplier)
  # perc_diff = (alpha*sigma - mean(lambdaj))/alpha*sigma
  # }

  
  #lambdaj <- rgamma(n,shape = alpha/sigma_multiplier,scale = sigma*sigma_multiplier)
  
  # for each cell use the latent expression and library size to simulate expression
  for(i in 1:n){
  
    Y[i] <- rpois(1,Li*lambdaj[i])
  }
  
  return(Y)
}
```

```{r Dispersion Histogram Low Alpha, warning=F}
set.seed(8626)
n=500
alpha = 0.5
sigma = 0.0002
Li = 8000

gene1 <- sim_gene(n,alpha,sigma,Li)
gene1.5 <- sim_gene(n,alpha,sigma,Li,1.5)
gene2 <- sim_gene(n,alpha,sigma,Li,2)
gene2.5 <- sim_gene(n,alpha,sigma,Li,2.5)
gene3 <- sim_gene(n,alpha,sigma,Li,3)

df1 = rbind(data.frame(factor='1', UMI=gene1), data.frame(factor='1.5', UMI=gene1.5), data.frame(factor='2', UMI=gene2), data.frame(factor='2.5', UMI=gene2.5), data.frame(factor='3', UMI=gene3))

group.colors <- c("red","blue","forestgreen","orange", "purple")

ggplot(df1, aes(UMI, fill=factor)) + 
  geom_histogram( alpha=1, position="dodge",binwidth=0.5) + scale_fill_manual(values=group.colors) + scale_color_manual(values=group.colors) + theme(legend.key.size = unit(0.5, 'cm'), legend.title = element_text(size=10)) + theme_bw() + xlim(-0.5, 10) + ggtitle("Histogram with Varying Dispersion for Low Alpha") 

```

```{r Dispersion Histogram High Alpha, warning=F}
set.seed(8626)
n=500
alpha = 5
sigma = 0.0002
Li = 8000

gene1 <- sim_gene(n,alpha,sigma,Li)
gene1.5 <- sim_gene(n,alpha,sigma,Li,1.5)
gene2 <- sim_gene(n,alpha,sigma,Li,2)
gene2.5 <- sim_gene(n,alpha,sigma,Li,2.5)
gene3 <- sim_gene(n,alpha,sigma,Li,3)

df1 = rbind(data.frame(factor='1', UMI=gene1), data.frame(factor='1.5', UMI=gene1.5), data.frame(factor='2', UMI=gene2), data.frame(factor='2.5', UMI=gene2.5), data.frame(factor='3', UMI=gene3))

group.colors <- c("red","blue","forestgreen","orange", "purple")

ggplot(df1, aes(UMI, fill=factor)) + 
  geom_histogram( alpha=1, position="dodge",binwidth=1) + scale_fill_manual(values=group.colors) + scale_color_manual(values=group.colors) + theme(legend.key.size = unit(0.5, 'cm'), legend.title = element_text(size=10)) + theme_bw() + ggtitle("Histogram with Varying Dispersion for High Alpha") + xlim(-0.5, 40) 

```

```{r, eval=F, include=F}
hist(cardiomyocytes_expression_data_filtered[,which.max(mean_relative_expression)], breaks=20)
```

## **Estimating Dispersion Parameter**

We have divided mean expression into groups of 500 bins. For each bin of mean expression, genes are grouped together and a Gamma-Poisson distribution is fit to the data to estimate the dispersion parameter. We use the **glm_gp** function from the *glmGamPoi* package to fit a Gamma-Poisson model that uses MLE to estimate $\mu$ and $dispersion (\phi)$ parameters. Using this parameterization, the mean is $\mu$ and the variance is $\mu + \mu^2\phi$.

[The manual for glmGamPoi can be found here.](https://www.bioconductor.org/packages/3.16/bioc/manuals/glmGamPoi/man/glmGamPoi.pdf)

```{r}
# require(fitdistrplus)
# require(MASS)
library(glmGamPoi)
library(dplyr)
# fitnb <- fitdist(cardiomyocytes_expression_data_filtered[,1],"nbinom", method="mle")
# 
# fitnb_mass <- fitdistr(cardiomyocytes_expression_data_filtered[,1], "Negative Binomial")
# summary(fitnb)
# plot(fitnb)

mu_values <- c()
disp_values <- c()

for(i in 1:500){
 # get indices for genes within bin of mean expression
 mean_idx <- which(between(mean_expression,mean_intervals[i],mean_intervals[i+1])) 
 
 if(length(mean_idx) > 0){
   # group genes into single vector of data
   grouped_data <- as.vector(cardiomyocytes_expression_data_filtered[,mean_idx])
   
   # fit gamma-poisson distribution
   fit_gp <- glm_gp(grouped_data, size_factors=1)
   sum_gp <- summary(fit_gp)
   
   # get mu and dispersion estimates
   mu <-  median(sum_gp$Mu)
   mu_values <- c(mu_values,mu)
   dispersion <- sum_gp$overdispersions
   disp_values <- c(disp_values,dispersion)
 }
 
}
```

```{r}
plot(mu_values, disp_values, pch=16, xlab="mean", ylab = "dispersion")
abline(h=mean(disp_values), col ="red", lwd=3)
text(8.3, 0.74, round(mean(disp_values),3), col ="red")
```
```{r}
#rowMeans(cardiomyocytes_expression_data_filtered)
#par(mfrow = c(1, 2))
card_cpm <- t(cpmNormalization(t(cardiomyocytes_expression_data_filtered)))
cv_card <- apply(card_cpm, 2, sd)/apply(card_cpm, 2, mean)
mean_card <- apply(card_cpm, 2, mean)

cv_card_raw <- apply(cardiomyocytes_expression_data_filtered, 2, sd)/apply(cardiomyocytes_expression_data_filtered, 2, mean)
mean_card_raw <- apply(cardiomyocytes_expression_data_filtered, 2, mean)

plot(log(mean_card),cv_card, main = "Cardiomyocytes CPM Normalized", xlab = "log(mean)", ylab = "CV", pch=16,cex=0.5)
plot(log(mean_card_raw),cv_card_raw, main = "Cardiomyocytes Raw", xlab = "log(mean)", ylab = "CV", pch=16,cex=0.5)
```


```{r,include=F,eval=F}
beta = c(rep(0,50),rexp(50))
y = rpois(100,beta) # simulate Poisson observations
y.ash = ash_pois(y,scale=1)
```


## **Simulating for Bins of Mean Expression**

### ***Parameter Estimations***
We have broken down the range of mean expression into 100 bins. For each bin we will simulate 100 genes. The mean expression, $\mu$, varies for the genes within each bin. So the background genes and dispersed genes fall within the same mean expression bin. We incorporate the estimated dispersion from the real data. The dispersion level is relatively similar across varying gene expression, so we use the mean dispersion level as our estimate: $\hat{\phi} = \frac{1}{n}\sum_i^n \phi_i$. 

We then use $\hat{\phi}$ to calculate $\sigma$ and $\alpha$ and respectively. From *glmGamPoi*:

$$
E[X] = \mu \hspace{20 mm} Var[X] = \mu + \mu^2\phi
$$

From the *rgamma* simulations:

$$
E[X] = \alpha\sigma \hspace{20 mm} Var[X] = \alpha\sigma^2
$$
Setting the equations equal to each other:

$$
\sigma = \mu\phi + 1 \hspace{20 mm} \alpha = \frac{\mu}{\mu\phi + 1}
$$

We use these equations to calculate $\sigma$ and $\alpha$. For 5% of genes we multiply $\sigma$ by these factors: 1.25, 1.5, 1.75, 2. These are the dispersed genes.


### ***Simulations***
```{r Bins of Mean Expression, include=F, eval=F}
# calculate alpha given mean expression and fixed sigma
calc_alpha <- function(mu, sigma){
  alpha = mu/sigma
  return(alpha)
}


# Function to simulate genes within a bin of mean expression
sim_bin <- function(n,p,sigma,sigma_multiplier,Li,mean_expr_lwr,mean_expr_upr){
  
  # Simulate all genes with following parameters:
  # n:                number of cells
  # p:                number of genes
  # phi:              estimated dispersion parameter
  # sigma:            sigma parameter
  # sigma_multiplier: factor to increase variance
  # Li:               library size
  # mean_expr_lwr:    lower bound of mean expression window
  # mean_expr_upr:    upper bound of mean expression window
 
  # Returns matrix of expression for n cells and p genes. 
  # Returns vector of index values for simulated dispersed genes.
  
  # initialize Y for bin of expression
  Y_bin <- matrix(NA,nrow=n,ncol=p)
  
  # breakdown expression range into p values
  bin_expression <- seq(mean_expr_lwr,mean_expr_upr,length.out=p)
  
  # randomly select p expression means
  bin_sim_idx <- sample.int(p, p, replace = TRUE)
  # randomly select 5% to be significantly dispersed
  bin_disp_idx <- sample.int(p, 0.05*p, replace = FALSE)
  # get expression means
  sim_expression_values <- bin_expression[bin_sim_idx]
  
  # simulate genes for each expression mean
  for(i in 1:p){
    
    # get expression mean
    mu <- sim_expression_values[i]
    # calculate alpha for fixed sigma based on expression mean
    alpha <- calc_alpha(mu,sigma)
    
    # for dispersed genes multiply sigma by factor
    if(i %in% bin_disp_idx){
      Y_bin[,i] <- sim_gene(n,alpha,sigma,Li,sigma_multiplier)
    }
    else{
      Y_bin[,i] <- sim_gene(n,alpha,sigma,Li)
    }
  }
  
  return(list("Y_bin"=Y_bin, "disp_idx"=bin_disp_idx))
}

sim_Y <- function(n,p,sigma,sigma_multiplier,Li,mean_intervals){
  Y <- c()
  disp_idx <- c()
  for(i in 1:100){
    
    mean_expr_lwr <- mean_intervals[i]
    mean_expr_upr <- mean_intervals[i+1]
    
    gene_sim <- sim_bin(n,p,sigma,sigma_multiplier,Li,mean_expr_lwr,mean_expr_upr)
    Y_bin <- gene_sim$Y_bin
    bin_disp_idx <- gene_sim$disp_idx + (i-1)*100
    
    Y <- cbind(Y,Y_bin)
    disp_idx <- c(disp_idx,bin_disp_idx)
  }
  return(list("Y"=Y,"disp_idx"=disp_idx))
}


cpm_norm <- function(Y){
  
  require(scTenifoldNet)
  Y_cpm_normalized <- t(cpmNormalization(t(Y)))
  Y_log_cpm_normalized <- log(t(cpmNormalization(t(Y))))
  
  Y_cv <- apply(Y_cpm_normalized, 2, sd)/apply(Y_cpm_normalized, 2, mean)
  Y_mean <- apply(Y_cpm_normalized, 2, mean)
  Y_cv_log <- apply(Y_log_cpm_normalized, 2, sd)/apply(Y_log_cpm_normalized, 2, mean)
  Y_mean_log <- apply(Y_log_cpm_normalized, 2, mean)
  
  return(list("Y_cpm_normalized"=Y_cpm_normalized, "Y_log_cpm_normalized" = Y_log_cpm_normalized, "Y_cv" = Y_cv, "Y_mean" = Y_mean, "Y_cv_log"=Y_cv_log, "Y_mean_log" = Y_mean_log))
}

```

```{r Bins of Mean Expression 2}
# calculate alpha given mean expression and fixed sigma
calc_alpha <- function(mu, sigma){
  alpha = mu/sigma
  return(alpha)
}


# Function to simulate genes within a bin of mean expression
sim_bin <- function(n,p,phi,sigma_multiplier,Li,mean_expr_lwr,mean_expr_upr){
  
  # Simulate all genes with following parameters:
  # n:                number of cells
  # p:                number of genes
  # phi:              estimated dispersion parameter
  # phi_multiplier:   factor to increase dispersion parameter
  # Li:               library size
  # mean_expr_lwr:    lower bound of mean expression window
  # mean_expr_upr:    upper bound of mean expression window
 
  # Returns matrix of expression for n cells and p genes. 
  # Returns vector of index values for simulated dispersed genes.
  
  # initialize Y for bin of expression
  Y_bin <- matrix(NA,nrow=n,ncol=p)
  
  # breakdown expression range into p values
  bin_expression <- seq(mean_expr_lwr,mean_expr_upr,length.out=p)
  
  # randomly select p expression means
  bin_sim_idx <- sample.int(p, p, replace = TRUE)
  # randomly select 5% to be significantly dispersed
  bin_disp_idx <- sample.int(p, 0.05*p, replace = FALSE)
  # get expression means
  sim_expression_values <- bin_expression[bin_sim_idx]
  
  # simulate genes for each expression mean
  for(i in 1:p){
    
    # get expression mean
    mu <- sim_expression_values[i]
    
    # calculate sigma parameter
    sigma <- mu*phi + 1
    #sigma_disp <- mu*phi*phi_multiplier + 1
    
    # calculate alpha for fixed sigma based on expression mean
    alpha <- calc_alpha(mu,sigma)
    #alpha_disp <- calc_alpha(mu,sigma_disp)
    
    # for dispersed genes multiply sigma by factor
    if(i %in% bin_disp_idx){
      Y_bin[,i] <- sim_gene(n,alpha,sigma,Li,sigma_multiplier)
    }
    else{
      Y_bin[,i] <- sim_gene(n,alpha,sigma,Li)
    }
  }
  
  return(list("Y_bin"=Y_bin, "disp_idx"=bin_disp_idx))
}

sim_Y <- function(n,p,phi,sigma_multiplier,Li,mean_intervals){
  Y <- c()
  disp_idx <- c()
  for(i in 1:p){
    
    mean_expr_lwr <- mean_intervals[i]
    mean_expr_upr <- mean_intervals[i+1]
    
    gene_sim <- sim_bin(n,p,phi,sigma_multiplier,Li,mean_expr_lwr,mean_expr_upr)
    Y_bin <- gene_sim$Y_bin
    bin_disp_idx <- gene_sim$disp_idx + (i-1)*p
    
    Y <- cbind(Y,Y_bin)
    disp_idx <- c(disp_idx,bin_disp_idx)
  }
  return(list("Y"=Y,"disp_idx"=disp_idx))
}


cpm_norm <- function(Y){
  
  require(scTenifoldNet)
  Y_cpm_normalized <- t(cpmNormalization(t(Y)))
  Y_log_cpm_normalized <- log(t(cpmNormalization(t(Y))))
  
  Y_cv <- apply(Y_cpm_normalized, 2, sd)/apply(Y_cpm_normalized, 2, mean)
  Y_mean <- apply(Y_cpm_normalized, 2, mean)
  Y_cv_log <- apply(Y_log_cpm_normalized, 2, sd)/apply(Y_log_cpm_normalized, 2, mean)
  Y_mean_log <- apply(Y_log_cpm_normalized, 2, mean)
  
  return(list("Y_cpm_normalized"=Y_cpm_normalized, "Y_log_cpm_normalized" = Y_log_cpm_normalized, "Y_cv" = Y_cv, "Y_mean" = Y_mean, "Y_cv_log"=Y_cv_log, "Y_mean_log" = Y_mean_log))
}

```

We simulate applying different factors to amplify the variance.


```{r}
#### Simulate Y matrix for all genes
set.seed(10012025)

# Parameters
n=500
p=100
phi = mean(disp_values)
#sigma=0.0002
Li = 8

#Y_1.25 <- sim_Y(n,p,phi,2,Li,mean_intervals)
# Y_1.5 <- sim_Y(n,p,phi,1.5,Li,mean_relative_intervals)
# Y_1.75 <- sim_Y(n,p,phi,1.75,Li,mean_relative_intervals)
# Y_2 <- sim_Y(n,p,phi,2,Li,mean_relative_intervals)
Y_1.25 <- sim_Y(n,p,phi,1.25,Li,mean_intervals)
Y_1.5 <- sim_Y(n,p,phi,1.5,Li,mean_intervals)
Y_1.75 <- sim_Y(n,p,phi,1.75,Li,mean_intervals)
Y_2 <- sim_Y(n,p,phi,2,Li,mean_intervals)

```


```{r, eval=F, include=F}
cpm_norm1.25 <- t(cpmNormalization(t(Y_1.25$Y)))
Y_1.25_cv_cpm <- apply(cpm_norm1.25, 2, sd)/apply(cpm_norm1.25, 2, mean)
Y_1.25_mean_cpm <- apply(cpm_norm1.25, 2, mean)

Y_1.25_cv <- apply(Y_1.25$Y, 2, sd)/apply(Y_1.25$Y, 2, mean)
Y_1.25_mean <- apply(Y_1.25$Y, 2, mean)

plot(log(Y_1.25_mean),Y_1.25_cv, pch=16, cex=0.5 ,main = "Raw - Factor: 2", xlab="log(mean)", ylab="CV")
points(log(Y_1.25_mean[Y_1.25$disp_idx]),Y_1.25_cv[Y_1.25$disp_idx],pch=16,col="red",cex=0.5)

plot(log(Y_1.25_mean_cpm),Y_1.25_cv_cpm, pch=16, cex=0.5 ,main = "CPM - Factor: 2", xlab="log(mean)", ylab="CV")
points(log(Y_1.25_mean_cpm[Y_1.25$disp_idx]),Y_1.25_cv_cpm[Y_1.25$disp_idx],pch=16,col="red",cex=0.5)
```

Perform normalization on data.

```{r}
Y_1.25_cpm <- cpm_norm(Y_1.25$Y)
Y_1.5_cpm <- cpm_norm(Y_1.5$Y)
Y_1.75_cpm <- cpm_norm(Y_1.75$Y)
Y_2_cpm <- cpm_norm(Y_2$Y)


Y_1.25_cv <- apply(Y_1.25$Y, 2, sd)/apply(Y_1.25$Y, 2, mean)
Y_1.25_mean <- apply(Y_1.25$Y, 2, mean)

Y_1.5_cv <- apply(Y_1.5$Y, 2, sd)/apply(Y_1.5$Y, 2, mean)
Y_1.5_mean <- apply(Y_1.5$Y, 2, mean)

Y_1.75_cv <- apply(Y_1.75$Y, 2, sd)/apply(Y_1.75$Y, 2, mean)
Y_1.75_mean <- apply(Y_1.75$Y, 2, mean)

Y_2_cv <- apply(Y_2$Y, 2, sd)/apply(Y_2$Y, 2, mean)
Y_2_mean <- apply(Y_2$Y, 2, mean)
```


```{r, include=F, eval=F}
par(mfrow = c(2, 2))

plot(log(Y_1.25_mean),Y_1.25_cv, pch=16, cex=0.5 ,main = "Factor: 1.25", xlab="log(mean)", ylab="CV")
points(log(Y_1.25_mean[Y_1.25$disp_idx]),Y_1.25_cv[Y_1.25$disp_idx],pch=16,col="red",cex=0.5)

plot(log(Y_1.5_mean),Y_1.5_cv, pch=16, cex=0.5 ,main = "Factor: 1.5", xlab="log(mean)", ylab="CV")
points(log(Y_1.5_mean[Y_1.5$disp_idx]),Y_1.5_cv[Y_1.5$disp_idx],pch=16,col="red",cex=0.5)

plot(log(Y_1.75_mean),Y_1.75_cv, pch=16, cex=0.5 ,main = "Factor: 1.75", xlab="log(mean)", ylab="CV")
points(log(Y_1.75_mean[Y_1.75$disp_idx]),Y_1.75_cv[Y_1.75$disp_idx],pch=16,col="red",cex=0.5)

plot(log(Y_2_mean),Y_2_cv, pch=16, cex=0.5 ,main = "Factor: 2", xlab="log(mean)", ylab="CV")
points(log(Y_2_mean[Y_2$disp_idx]),Y_2_cv[Y_2$disp_idx],pch=16,col="red",cex=0.5)
mtext("No Normalization", side = 3, line = - 1, outer = TRUE)
```

We look at the CV curve of the simulated data. The red dots indicate genes with increased dispersion.

```{r}
par(mfrow = c(2, 2))

plot(log(Y_1.25_cpm$Y_mean),Y_1.25_cpm$Y_cv, pch=16, cex=0.5 ,main = "Factor: 1.25", xlab="log(mean)", ylab="CV")
points(log(Y_1.25_cpm$Y_mean[Y_1.25$disp_idx]),Y_1.25_cpm$Y_cv[Y_1.25$disp_idx],pch=16,col="red",cex=0.5)

plot(log(Y_1.5_cpm$Y_mean),Y_1.5_cpm$Y_cv, pch=16, cex=0.5 ,main = "Factor: 1.5", xlab="log(mean)", ylab="CV")
points(log(Y_1.5_cpm$Y_mean[Y_1.5$disp_idx]),Y_1.5_cpm$Y_cv[Y_1.5$disp_idx],pch=16,col="red",cex=0.5)

plot(log(Y_1.75_cpm$Y_mean),Y_1.75_cpm$Y_cv, pch=16, cex=0.5 ,main = "Factor: 1.75", xlab="log(mean)", ylab="CV")
points(log(Y_1.75_cpm$Y_mean[Y_1.75$disp_idx]),Y_1.75_cpm$Y_cv[Y_1.75$disp_idx],pch=16,col="red",cex=0.5)

plot(log(Y_2_cpm$Y_mean),Y_2_cpm$Y_cv, pch=16, cex=0.5 ,main = "Factor: 2", xlab="log(mean)", ylab="CV")
points(log(Y_2_cpm$Y_mean[Y_2$disp_idx]),Y_2_cpm$Y_cv[Y_2$disp_idx],pch=16,col="red",cex=0.5)
mtext("CPM Normalized", side = 3, line = - 1, outer = TRUE)
```


## **Identifying Significant Genes on Simulated Data**

We run the pipeline (CV + bootstrapping) to identify genes with significant dispersion.

```{r load results}
path = "/project2/gilad/awchen55/differentialDispersion/data/simulations"

# index of simulated dispersed genes
disp_idx_1.25 <- read.csv(file.path(path, "sim_raw_sig_disp_idx_1.25.csv"))
disp_idx_1.25 <- disp_idx_1.25[2:ncol(disp_idx_1.25)]

disp_idx_1.5 <- read.csv(file.path(path, "sim_raw_sig_disp_idx_1.5.csv"))
disp_idx_1.5 <- disp_idx_1.5[2:ncol(disp_idx_1.5)]

disp_idx_1.75 <- read.csv(file.path(path, "sim_raw_sig_disp_idx_1.75.csv"))
disp_idx_1.75 <- disp_idx_1.75[2:ncol(disp_idx_1.75)]

disp_idx_2 <- read.csv(file.path(path, "sim_raw_sig_disp_idx_2.csv"))
disp_idx_2 <- disp_idx_2[2:ncol(disp_idx_2)]

# pipeline results
sim1.25 <- read.csv(file.path(path,"simulation_bootstrap_results_1.25_cpm.csv"))
sim1.5 <- read.csv(file.path(path,"simulation_bootstrap_results_1.5_cpm.csv"))
sim1.75 <- read.csv(file.path(path,"simulation_bootstrap_results_1.75_cpm.csv"))
sim2 <- read.csv(file.path(path,"simulation_bootstrap_results_2_cpm.csv"))

sim1.25["mean"] <- sim1.25["umi"]/500
sim1.5["mean"] <- sim1.5["umi"]/500
sim1.75["mean"] <- sim1.75["umi"]/500
sim2["mean"] <- sim2["umi"]/500

```

```{r}
load_raw_data <- function(path, df_name){
  df <-  read.csv(file.path(path,df_name))
  df <- t(df[,2:ncol(df)])
  colnames(df) <- df[1,]
  df <- df[-1,]
  df <- cbind(newColName = rownames(df), as.numeric(df[,"mean"]))
  colnames(df) <- c("X","mean_raw")
  return(df)
}

```

```{r}

# add raw UMI measurements to data
sim_raw_metrics_1.25 <- load_raw_data(path,"simulation_metrics_1.25_raw.csv")
sim_raw_metrics_1.5 <- load_raw_data(path,"simulation_metrics_1.5_raw.csv")
sim_raw_metrics_1.75 <- load_raw_data(path,"simulation_metrics_1.75_raw.csv")
sim_raw_metrics_2 <- load_raw_data(path,"simulation_metrics_2_raw.csv")


sim1.25 <- left_join(sim1.25, as.data.frame(sim_raw_metrics_1.25), by = "X")
sim1.5 <- left_join(sim1.5, as.data.frame(sim_raw_metrics_1.5), by = "X")
sim1.75 <- left_join(sim1.75, as.data.frame(sim_raw_metrics_1.75), by = "X")
sim2 <- left_join(sim2, as.data.frame(sim_raw_metrics_2), by = "X")

sim1.25[,"mean_raw"] <- as.numeric(sim1.25[,"mean_raw"])
sim1.5[,"mean_raw"] <- as.numeric(sim1.5[,"mean_raw"])
sim1.75[,"mean_raw"] <- as.numeric(sim1.75[,"mean_raw"])
sim2[,"mean_raw"] <- as.numeric(sim2[,"mean_raw"])
```

```{r}
library(dplyr)

# calculate number of true positive, false positives, etc.

sim1.25_sig <- sim1.25 %>%
  filter(p_value_adj < 0.05)

TP_1.25 <- sim1.25[do.call(cbind, lapply(disp_idx_1.25, unlist)),]%>%
  filter(p_value_adj < 0.05, z_score < 0)

FP_1.25 <- sim1.25[-do.call(cbind, lapply(disp_idx_1.25, unlist)),]%>%
  filter(p_value_adj < 0.05, z_score < 0)

FN_1.25 <- sim1.25[do.call(cbind, lapply(disp_idx_1.25, unlist)),]%>%
  filter(p_value_adj > 0.05)

sim1.5_sig <- sim1.5 %>%
  filter(p_value_adj < 0.05, z_score < 0)

TP_1.5 <- sim1.5[do.call(cbind, lapply(disp_idx_1.5, unlist)),]%>%
  filter(p_value_adj < 0.05, z_score < 0)

FP_1.5 <- sim1.5[-do.call(cbind, lapply(disp_idx_1.5, unlist)),]%>%
  filter(p_value_adj < 0.05, z_score < 0)

FN_1.5 <- sim1.5[do.call(cbind, lapply(disp_idx_1.5, unlist)),]%>%
  filter(p_value_adj > 0.05)

sim1.75_sig <- sim1.75 %>%
  filter(p_value_adj < 0.05, z_score < 0)

TP_1.75 <- sim1.75[do.call(cbind, lapply(disp_idx_1.75, unlist)),]%>%
  filter(p_value_adj < 0.05, z_score < 0)

FP_1.75 <- sim1.75[-do.call(cbind, lapply(disp_idx_1.75, unlist)),]%>%
  filter(p_value_adj < 0.05, z_score < 0)

FN_1.75 <- sim1.75[do.call(cbind, lapply(disp_idx_1.75, unlist)),]%>%
  filter(p_value_adj > 0.05)

sim2_sig <- sim2 %>%
  filter(p_value_adj < 0.05, z_score < 0)

TP_2 <- sim2[do.call(cbind, lapply(disp_idx_2, unlist)),]%>%
  filter(p_value_adj < 0.05, z_score < 0)
FP_2 <- sim2[-do.call(cbind, lapply(disp_idx_2, unlist)),]%>%
  filter(p_value_adj < 0.05, z_score < 0)

FN_2 <- sim2[do.call(cbind, lapply(disp_idx_2, unlist)),]%>%
  filter(p_value_adj > 0.05)
```


```{r}

# Data cleaning
sim1.25 <- sim1.25 %>%
  mutate(result=case_when(
    rownames(sim1.25) %in% disp_idx_1.25 & p_value_adj < 0.05 &  z_score < 0 ~ "TP",
    rownames(sim1.25) %in% disp_idx_1.25 & p_value_adj > 0.05 ~ "FN",
    !(rownames(sim1.25) %in% disp_idx_1.25)& p_value_adj < 0.05 &  z_score < 0 ~ "FP",
    !(rownames(sim1.25) %in% disp_idx_1.25)& p_value_adj > 0.05  ~ "TN",
    TRUE ~ "FP Under"
  ), mean_bucket=case_when(
    mean_raw < 1~ "low",
    mean_raw > 5 ~ "high",
    TRUE ~ "medium"
  ))

sim1.25$result <- factor(sim1.25$result, levels = c("TN", "FN", "TP","FP","FP Under"))

sim1.5 <- sim1.5 %>%
  mutate(result=case_when(
    rownames(sim1.5) %in% disp_idx_1.5 & p_value_adj < 0.05 &  z_score < 0 ~ "TP",
    rownames(sim1.5) %in% disp_idx_1.5 & p_value_adj > 0.05 ~ "FN",
    !(rownames(sim1.5) %in% disp_idx_1.5)& p_value_adj < 0.05 &  z_score < 0 ~ "FP",
    !(rownames(sim1.5) %in% disp_idx_1.5)& p_value_adj > 0.05  ~ "TN",
    TRUE ~ "FP Under"
  ), mean_bucket=case_when(
    mean_raw < 1~ "low",
    mean_raw > 5 ~ "high",
    TRUE ~ "medium"
  ))

sim1.5$result <- factor(sim1.5$result, levels = c("TN", "FN", "TP","FP","FP Under"))

sim1.75 <- sim1.75 %>%
  mutate(result=case_when(
    rownames(sim1.75) %in% disp_idx_1.75 & p_value_adj < 0.05 &  z_score < 0 ~ "TP",
    rownames(sim1.75) %in% disp_idx_1.75 & p_value_adj > 0.05 ~ "FN",
    !(rownames(sim1.75) %in% disp_idx_1.75)& p_value_adj < 0.05 &  z_score < 0 ~ "FP",
    !(rownames(sim1.75) %in% disp_idx_1.75)& p_value_adj > 0.05  ~ "TN",
    TRUE ~ "FP Under"
  ), mean_bucket=case_when(
    mean_raw < 1~ "low",
    mean_raw > 5 ~ "high",
    TRUE ~ "medium"
  ))

sim1.75$result <- factor(sim1.75$result, levels = c("TN", "FN", "TP","FP","FP Under"))

sim2 <- sim2 %>%
  mutate(result=case_when(
    rownames(sim2) %in% disp_idx_2 & p_value_adj < 0.05 &  z_score < 0 ~ "TP",
    rownames(sim2) %in% disp_idx_2 & p_value_adj > 0.05 ~ "FN",
    !(rownames(sim2) %in% disp_idx_2)& p_value_adj < 0.05 &  z_score < 0 ~ "FP",
    !(rownames(sim2) %in% disp_idx_2)& p_value_adj > 0.05  ~ "TN",
    TRUE ~ "FP Under"
  ), mean_bucket=case_when(
    mean_raw < 1~ "low",
    mean_raw > 5 ~ "high",
    TRUE ~ "medium"
  ))

sim2$result <- factor(sim2$result, levels = c("TN", "FN", "TP","FP","FP Under"))

```

We compare the performance of identifying significantly dispersed genes for higher dispersion.
```{r, warning=F, message=F}
library(ggplot2)
scaleFUN <- function(x) sprintf("%.1f", x)

plot_1.25 <- ggplot(sim1.25, aes(x=mean_raw, y=cv, color=result)) +
  geom_point(size=1,alpha=0.5) + scale_color_manual(values = c("TN"="grey", "FN" = "blue", "TP" = "forestgreen", "FP" = "red","FP Under" = "purple")) + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"),plot.title = element_text(hjust = 0.5)) + labs(title="Factor: 1.25", x ="", y = "CV")+ geom_point(data=FN_1.25,aes(x=mean_raw,y=cv), color="blue", alpha=0.25) + geom_point(data=TP_1.25,aes(x=mean_raw,y=cv), color="forestgreen", alpha=0.5) + scale_x_continuous(trans = "log",labels=scaleFUN,breaks=c(0.1,1,5,20)) + ylim(0, 10)

plot_1.5 <- ggplot(sim1.5, aes(x=mean_raw, y=cv, color=result)) +
  geom_point(size=1,alpha=0.5) + scale_color_manual(values = c("TN"="grey", "FN" = "blue", "TP" = "forestgreen", "FP" = "red","FP Under" = "purple")) + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"), plot.title = element_text(hjust = 0.5)) + labs(title="Factor: 1.5", x ="", y = "") + geom_point(data=TP_1.5,aes(x=mean_raw,y=cv), color="forestgreen", alpha=0.5) + geom_point(data=FN_1.5,aes(x=mean_raw,y=cv), color="blue", alpha=0.1) + geom_point(data=FP_1.5,aes(x=mean_raw,y=cv), color="red", alpha=0.5) + scale_x_continuous(trans = "log",labels=scaleFUN,breaks=c(0.1,1,5,20)) + ylim(0, 10)

plot_1.75 <- ggplot(sim1.75, aes(x=mean_raw, y=cv, color=result)) +
  geom_point(size=1,alpha=0.5) + scale_color_manual(values = c("TN"="grey", "FN" = "blue", "TP" = "forestgreen", "FP" = "red","FP Under" = "purple")) + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"), plot.title = element_text(hjust = 0.5)) + labs(title="Factor: 1.75", x ="mean(UMI)", y = "CV") + geom_point(data=TP_1.75,aes(x=mean_raw,y=cv), color="forestgreen", alpha=0.5) + geom_point(data=FN_1.75,aes(x=mean_raw,y=cv), color="blue", alpha=0.25) + geom_point(data=FP_1.75,aes(x=mean_raw,y=cv), color="red", alpha=0.5) + scale_x_continuous(trans = "log",labels=scaleFUN,breaks=c(0.1,1,5,20)) + ylim(0, 10)

plot_2 <- ggplot(sim2) + geom_point(aes(x=mean_raw, y=cv, color=result),size=1,alpha=0.5) + scale_color_manual(values = c("TN"="grey", "FN" = "blue", "TP" = "forestgreen", "FP" = "red","FP Under" = "purple")) + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"), plot.title = element_text(hjust = 0.5)) + labs(title="Factor: 2", x ="mean(UMI)", y = "") + geom_point(data=TP_2,aes(x=mean_raw,y=cv), color="forestgreen", alpha=0.5) + geom_point(data=FN_2,aes(x=mean_raw,y=cv), color="blue", alpha=0.25) + geom_point(data=FP_2,aes(x=mean_raw,y=cv), color="red", alpha=0.5) +scale_x_continuous(trans = "log",labels=scaleFUN, breaks=c(0.1,1,5,20)) + ylim(0, 10)

plot_1.25 + plot_1.5 + plot_1.75 + plot_2
```

```{r}
library(dplyr)
# calculate the 

calc_performance <- function(summary_df){
  TN <- (summary_df  %>% filter(result == "TN"))$count
  TN <- ifelse(is.null(TN),0,TN)
  FN <- (summary_df  %>% filter(result == "FN"))$count
  FN <- ifelse(is.null(FN),0,FN)
  TP <- (summary_df  %>% filter(result == "TP"))$count
  TP <- ifelse(is.null(TP),0,TP)
  FP <- (summary_df  %>% filter(result == "FP"))$count
  FP <- ifelse(is.null(FP),0,FP)
  FP_Under <- (summary_df  %>% filter(result == "FP Under"))$count
  FP_Under <- ifelse(is.null(FP_Under),0,FP_Under)
  
  TPR <- TP/(TP+FN + FP_Under)
  FNR <- FN/(TP+FN + FP_Under)
  FDR <- FP/(FP+TP)
  FPR <- FP/(TN+FP)
  
  res <- cbind(TP,FN,FP,TN,FP_Under, TPR,FNR, FPR, FDR)
  
  return(res)
}

combine_results_mean_buckets <- function(sim_res_df){

  summary_sim2 <-  sim_res_df %>%
    group_by(mean_bucket, result) %>%
    summarise(count = n(), .groups = 'drop')
  
  mean_buckets <- c("low","medium","high")
  res2 <- rbind(calc_performance(summary_sim2 %>% filter(mean_bucket=="low")),calc_performance(summary_sim2 %>% filter(mean_bucket=="medium")), calc_performance(summary_sim2 %>% filter(mean_bucket=="high")))
  
  rownames(res2) <- mean_buckets
  return(res2)
}

```


```{r}
summary_sim1.25 <-  sim1.25 %>%
    group_by(result) %>%
    summarise(count = n(), .groups = 'drop')
summary_sim1.5 <-  sim1.5 %>%
    group_by(result) %>%
    summarise(count = n(), .groups = 'drop')
summary_sim1.75 <-  sim1.75 %>%
    group_by(result) %>%
    summarise(count = n(), .groups = 'drop')
summary_sim2 <-  sim2 %>%
    group_by(result) %>%
    summarise(count = n(), .groups = 'drop')

perf_sim1.25 <- calc_performance(summary_sim1.25)
perf_sim1.5 <- calc_performance(summary_sim1.5)
perf_sim1.75 <- calc_performance(summary_sim1.75)
perf_sim2 <- calc_performance(summary_sim2)

applied_factor <- c(1.25,1.5,1.75,2)

perf_FDR <- c(perf_sim1.25[8],perf_sim1.5[8],perf_sim1.75[8],perf_sim2[8])
perf_FPR <- c(perf_sim1.25[7],perf_sim1.5[7],perf_sim1.75[7],perf_sim2[7])
perf_FNR <- c(perf_sim1.25[6],perf_sim1.5[6],perf_sim1.75[6],perf_sim2[6])

```


```{r, warning=F, message=F}
summary_performance <- rbind(perf_sim1.25,perf_sim1.5,perf_sim1.75,perf_sim2)
summary_performance <- cbind(applied_factor, summary_performance)

colors <- c("FDR" = "red", "FNR" = "steelblue", "FPR" = "forestgreen")

plot_perf1 <- ggplot(summary_performance, aes(x=applied_factor)) + 
  geom_line(aes(y = FDR,color = "FDR"), linetype = "dashed") + geom_point(aes(y = FDR),color = "red")+
  geom_line(aes(y = FNR, color="FNR"), linetype="dashed") + geom_point(aes(y = FNR),color = "steelblue")+
  geom_line(aes(y = FPR, color="FPR"), linetype="dashed") + geom_point(aes(y = FPR),color = "forestgreen") +
  labs(x = "Applied Factor",
         y = "(%)",
         color = "Result") +
    scale_color_manual(values = colors) + theme( panel.background = element_blank(), axis.line = element_line(colour = "black"))

plot_roc <- ggplot(summary_performance, aes(x=FPR,y=TPR)) + geom_line(linetype = "dashed") +  geom_point() +
  labs(x = "False Positive Rate",
         y = "True Positive Rate")  + theme( panel.background = element_blank(), axis.line = element_line(colour = "black"))

plot_perf1 + plot_roc
```
We also provide a table of the results.
```{r}
round(summary_performance,5)
```

The results are also broken down by expression level for each applied factor. We define genes as having low expression if the $mean(UMI) < 1$, medium expression if $1 \leq mean(UMI) \leq 5$, and high expression if $mean(UMI) > 5$

### ***Factor: 1.25***
```{r}
combine_results_mean_buckets(sim1.25)
```
### ***Factor: 1.5***
```{r}
combine_results_mean_buckets(sim1.5)
```

### ***Factor: 1.75***
```{r}
combine_results_mean_buckets(sim1.75)
```

### ***Factor: 2***
```{r}
combine_results_mean_buckets(sim2)
```


```{r write data, include=F, eval=F}


library(MASS)
#write.csv(as.data.frame(Y_1.25$Y), file = "/project2/gilad/awchen55/differentialDispersion/data/simulations/sim_1.25_raw.csv", row.names = FALSE)
# write.csv(as.data.frame(Y_1.5$Y), file = "/project2/gilad/awchen55/differentialDispersion/data/simulations/sim_1.5_raw.csv", row.names = FALSE)
# write.csv(as.data.frame(Y_1.75$Y), file = "/project2/gilad/awchen55/differentialDispersion/data/simulations/sim_1.75_raw.csv", row.names = FALSE)
# write.csv(as.data.frame(Y_2$Y), file = "/project2/gilad/awchen55/differentialDispersion/data/simulations/sim_2_raw.csv", row.names = FALSE)

write.csv(as.data.frame(Y_1.25_cpm$Y_cpm_normalized), file = "/project2/gilad/awchen55/differentialDispersion/data/simulations/sim_1.25_cpm.csv", row.names = FALSE)
write.csv(as.data.frame(Y_1.5_cpm$Y_cpm_normalized), file = "/project2/gilad/awchen55/differentialDispersion/data/simulations/sim_1.5_cpm.csv", row.names = FALSE)
write.csv(as.data.frame(Y_1.75_cpm$Y_cpm_normalized), file = "/project2/gilad/awchen55/differentialDispersion/data/simulations/sim_1.75_cpm.csv", row.names = FALSE)
write.csv(as.data.frame(Y_2_cpm$Y_cpm_normalized), file = "/project2/gilad/awchen55/differentialDispersion/data/simulations/sim_2_cpm.csv", row.names = FALSE)

#write.matrix(matrix(Y_1.25$Y,nrow=500,ncol=10000),file="/project2/gilad/awchen55/differentialDispersion/data/simulations/sim_1.25_raw.csv")
# write.matrix(Y_1.25_cpm$Y_cpm_normalized,file="/project2/gilad/awchen55/differentialDispersion/data/simulations/sim_1.25_cpm.csv")
# 
# write.matrix(Y_1.5_cpm$Y_cpm_normalized,file="/project2/gilad/awchen55/differentialDispersion/data/simulations/sim_1.5_cpm.csv")
# write.matrix(Y_1.75_cpm$Y_cpm_normalized,file="/project2/gilad/awchen55/differentialDispersion/data/simulations/sim_1.75_cpm.csv")
# write.matrix(Y_2_cpm$Y_cpm_normalized,file="/project2/gilad/awchen55/differentialDispersion/data/simulations/sim_2_cpm.csv")
# 
# write.csv(matrix(Y_1.25$disp_idx, nrow=1), file ="/project2/gilad/awchen55/differentialDispersion/data/simulations/sim_raw_sig_disp_idx_1.25.csv")
# write.csv(matrix(Y_1.5$disp_idx, nrow=1), file ="/project2/gilad/awchen55/differentialDispersion/data/simulations/sim_raw_sig_disp_idx_1.5.csv")
# write.csv(matrix(Y_1.75$disp_idx, nrow=1), file ="/project2/gilad/awchen55/differentialDispersion/data/simulations/sim_raw_sig_disp_idx_1.75.csv")
# write.csv(matrix(Y_2$disp_idx, nrow=1), file ="/project2/gilad/awchen55/differentialDispersion/data/simulations/sim_raw_sig_disp_idx_2.csv")
```



```{r, include=F,eval=F}
par(mfrow = c(2, 2))

plot(Y_1.25_cpm$Y_mean_log,Y_1.25_cpm$Y_cv_log, pch=16, cex=0.5 ,main = "Factor: 1.25", xlab="log(mean)", ylab="CV")
points(Y_1.25_cpm$Y_mean_log[Y_1.25$disp_idx],Y_1.25_cpm$Y_cv_log[Y_1.25$disp_idx],pch=16,col="red",cex=0.5)

plot(Y_1.5_cpm$Y_mean_log,Y_1.5_cpm$Y_cv_log, pch=16, cex=0.5 ,main = "Factor: 1.5", xlab="log(mean)", ylab="CV")
points(Y_1.5_cpm$Y_mean_log[Y_1.5$disp_idx],Y_1.5_cpm$Y_cv_log[Y_1.5$disp_idx],pch=16,col="red",cex=0.5)

plot(Y_1.75_cpm$Y_mean_log,Y_1.75_cpm$Y_cv_log, pch=16, cex=0.5 ,main = "Factor: 1.75", xlab="log(mean)", ylab="CV")
points(Y_1.75_cpm$Y_mean_log[Y_1.75$disp_idx],Y_1.75_cpm$Y_cv_log[Y_1.75$disp_idx],pch=16,col="red",cex=0.5)

plot(Y_2_cpm$Y_mean_log,Y_2_cpm$Y_cv_log, pch=16, cex=0.5 ,main = "Factor: 2", xlab="log(mean)", ylab="CV")
points(Y_2_cpm$Y_mean_log[Y_2$disp_idx],Y_2_cpm$Y_cv_log[Y_2$disp_idx],pch=16,col="red",cex=0.5)

mtext("Log CPM Normalized", side = 3, line = - 1, outer = TRUE)

```

```{r Single Gene Example, include=F,eval=F}
# We estimate the mean and variance from the relative expression to calculate estimates for $\alpha = mean^2/variance$ and $\sigma = variance/mean$.

alphas <- mean_relative_expression^2/var_relative_expression
sigmas <- var_relative_expression/mean_relative_expression


# We use the estimates for $\alpha$ and $\sigma$ to simulate the $\lambda_j \sim Gamma(\alpha,\sigma)$. The simulated $\lambda_j$ and library size $L_i$ are used to simulate $y_{ij} \sim Pois(L_i\lambda_j)$. We do this first for 1 example gene.


set.seed(8626)
n=500
gamma_dist <- rgamma(n,shape = alphas[1],scale = sigmas[1])
library_size_lambda <- library_sizes[1]*gamma_dist

yi <- c()
for(i in 1:n){
  yi <- c(yi,rpois(1,library_size_lambda[1]))
}



# We compare the histograms of UMI in 1 real versus simulated gene.



df1 = rbind(data.frame(grp='real data', UMI=cardiomyocytes_expression_data_filtered[,1]), data.frame(grp='simulated', UMI=yi))
group.colors <- c("red","blue")
ggplot(df1, aes(UMI, fill=grp)) + 
  geom_histogram(color='black', alpha=1, position="dodge",binwidth=0.5) + scale_fill_manual(values=group.colors)
```
