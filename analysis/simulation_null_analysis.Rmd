---
title: "**Poisson and Negative Binomial Simulations**"
output: html_document
date: '2024-07-24'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# **Simulation Details**

We simulate a matrix $Y \in \mathbb{R}^{n\times p}$ that contains raw expression values (scRNA-seq counts) for $p$ genes and $n$ single cells. We set $\pi$ as the percent of genes that are overdispersed. We use a Gamma-Poisson model for each gene and can set the dispersion level for each simulated gene.

```{r, eval=F,include=F}
## **Poisson Distribution**

### ***Model***

We first simulate a Poisson distribution as our null model for each gene, where there is no dispersion parameter.

$$
y_{ij} \sim Pois(L_i\lambda_j) 
$$

Where the variables for cell $i$ and gene $j$ are:

-   $y_{ij}$ is the number of unique molecular identifier (UMI) for cell $i$ and gene $j$

-   $L_i$ is the library size of cell $i$

-   $\lambda_j$ is the relative expression value of gene $j$

### ***Density Function***

The density function for the Poisson distribution is:

$$
f(y;\lambda) = \frac{\lambda^y e^{-\lambda}}{y!}
$$

Where for $y =0,1,2,...$ the $E[Y] = Var[Y] = \lambda$.

### ***Simulation Parameters***

We use the **rpois(**$n$, $\lambda$) function in R to simulate the Poisson distribution. The library size and relative expression values are calculated from a real data set (human-chimp hybrid data). Each $Y$ is calculated for cells from the same species, cell type, and replicate. We simulate for $n=500$ cells.
```

## **Gamma-Poisson (NB) Distribution**

### ***Model***

We simulate the Negative Binomial distribution using the Gamma-Poisson distribution, since the Gamma distribution is a conjugate prior of the Poisson distribution. Under this model,

$$
y_{ij} \sim Pois(L_i \lambda_{ij})
$$

$$
\lambda_{ij} \sim \begin{equation}
  f_j(\cdot) =
    \begin{cases}
      Gamma(\mu_{j_0},\phi_{j_0}) & \text{for background gene} \\
      Gamma(\mu_j,\phi_j) & \text{for overdispersed gene} \\
    \end{cases}       
\end{equation}
$$

Where the variables for cell $i$ and gene $j$ are:

-   $y_{ij}$ is the number of unique molecular identifier (UMI) for cell $i$ and gene $j$

-   $L_i$ is the library size of cell $i$

-   $\lambda_{ij}$ is the latent expression value of gene $j$

-   $\mu_j$ is the mean relative expression value of $\lambda_{ij}$ for gene $j$

-   $\mu_{j_0}$ is the null mean relative expression value for a background gene

-   $\phi_j$ is the dispersion value of $\lambda_{ij}$ for gene $j$

-   $\phi_{j_0}$ is the null dispersion value for a background gene

### ***Density Function***

The density function for the Gamma distribution is:

$$
f(y; \mu,\phi) = \frac{(\phi^{-1}\mu^{-1})^{\phi^{-1}}}{\Gamma(\phi^{-1})} y^{\phi^{-1}-1} e^{\phi^{-1}\mu^{-1}y}
$$

Where for $y =0,1,2,...$ the $E[Y] = \mu$ and $Var[Y] = \mu^2 \phi$.

### ***Simulation Parameters***

We will first simulate $\lambda_j$ using the **rgamma(**$n$,$\alpha$,$\sigma$) function in R with mean $\alpha\sigma$ and variance $\alpha\sigma^2$. Thus, $\mu=\alpha\sigma$ and $\phi = 1/\alpha$. We calculate $\mu_j$ for each gene $j$ and $L_i$ for each cell $i$ from the hybrid data set. For genes with dispersion, the $E[f] = \mu_0$. We next simulate the Poisson distribution using the **rpois(**$n$, $\lambda$) function in R. We simulate for $n=500$ cells.

```{r, eval=F,include=F}
## **Negative Binomial Distribution**

We simulate the Negative Binomial distribution as the the alternative model for each gene. The density function is:

$$
f(y;\mu, \theta) = {y+\theta-1 \choose y} \left(\frac{\mu}{\mu+\theta}\right)^y \left(\frac{\theta}{\mu+\theta}\right)^\theta 
$$ where for $y =0,1,2,...$ the $E[Y] = \mu$ and $Var[Y] = \mu + \frac{\mu^2}{\theta}$. Note that the *dispersion* parameter is $\phi=1/\theta$. We use the **rnegbin(**$n$, $\mu$, $\theta$) function from the *MASS* R package to simulate the Negative Binomial distribution.

$$
y_{ij} \sim NB(\mu_j,\theta_j) \text{ ,    where } j = 1,\cdots,p
$$

We set $\mu_j$ equal to the mean gene expression using raw counts from the hybrid data set. Mean gene expression is calculated across cells from the same species, replicate, and cell type. We introduce and test varying dispersion levels for $\phi_j = 1/\theta_j$ and simulate for $n=500$ cells.

```

# **Simulations**

We first calculate the mean gene expression for in the hybrid dataset using Human Cardiomyocytes from Replicate 3. Replicate 3 was chosen since there are 546 cells, which is similar to the 500 cells we will simulate.

```{r, message=F, warning=F}
require(Seurat)
require(SeuratDisk)
require(SeuratData)
library(ggplot2)
library(cowplot)
library(scTenifoldNet)
HC <- LoadH5Seurat("/project2/gilad/awchen55/differentialDispersion/data/hybrid_lines_raw_data/human.ASE.Rep3.h5Seurat")
cardiomyocytes_data <- subset(HC, subset = (labels == "Cardiomyocytes"))
cardiomyocytes_expression_data <- t(cardiomyocytes_data[['RNA']]$counts)
```

We filter for low expression genes and calculate the $L_i$ and relative expression to get $\lambda_j$ values.

```{r}
# calculate mean expression and remove genes with low expression
cardiomyocytes_expression_data_filtered <- cardiomyocytes_expression_data[, colSums(cardiomyocytes_expression_data != 0) > 50]

# calculate library size
library_sizes <- rowSums(cardiomyocytes_expression_data_filtered)

# calculate mean expression
mean_expression <- colMeans(cardiomyocytes_expression_data_filtered)

# calculate the relative expression for each cell (quantity/rowsum)
relative_expression <- t(apply(cardiomyocytes_expression_data_filtered,1, function(x) x/sum(x)))

# calculate mean relative expression per gene
mean_relative_expression <- colMeans(relative_expression)

# calculate variance relative expression per gene
var_relative_expression <-c()
for(i in 1:length(mean_relative_expression)){
  var_relative_expression <- c(var_relative_expression,var(relative_expression[,i]))
}
```

## **Mean Estimation**

We calculate the sample mean of genes to get an idea of ranges of mean expression. This will inform us of how to bin mean expression.

```{r}
hist(mean_relative_expression, breaks=100)
```

```{r}
hist(mean_expression, breaks=100)
```

```{r}
# get the intervals of relative mean expression
#mean_intervals <- seq(min(mean_relative_expression), max(mean_relative_expression),length.out=101)
mean_intervals <- seq(min(mean_expression), 10,length.out=501)
#mean_intervals <- seq(min(mean_relative_expression), 0.001,length.out=501)
```

## **Estimating Dispersion Parameter**

We have divided mean expression into groups of 500 bins. For each bin of mean expression, genes are grouped together and a Gamma-Poisson distribution is fit to the data to estimate the dispersion parameter. We use the **glm_gp** function from the *glmGamPoi* package to fit a Gamma-Poisson model that uses MLE to estimate $\mu$ and $dispersion$ parameters. Using this parameterization, the mean is $\mu$ and the variance is $\mu + \mu^2*dispersion$.

[The manual for glmGamPoi can be found here.](https://www.bioconductor.org/packages/3.16/bioc/manuals/glmGamPoi/man/glmGamPoi.pdf)

```{r}
# require(fitdistrplus)
# require(MASS)
library(glmGamPoi)
library(dplyr)
# fitnb <- fitdist(cardiomyocytes_expression_data_filtered[,1],"nbinom", method="mle")
# 
# fitnb_mass <- fitdistr(cardiomyocytes_expression_data_filtered[,1], "Negative Binomial")
# summary(fitnb)
# plot(fitnb)

mu_values <- c()
disp_values <- c()

for(i in 1:500){
 # get indices for genes within bin of mean expression
 mean_idx <- which(between(mean_expression,mean_intervals[i],mean_intervals[i+1])) 
 
 if(length(mean_idx) > 0){
   # group genes into single vector of data
   grouped_data <- as.vector(cardiomyocytes_expression_data_filtered[,mean_idx])
   
   # fit gamma-poisson distribution
   fit_gp <- glm_gp(grouped_data, size_factors=1)
   sum_gp <- summary(fit_gp)
   
   # get mu and dispersion estimates
   mu <-  median(sum_gp$Mu)
   mu_values <- c(mu_values,mu)
   dispersion <- sum_gp$overdispersions
   disp_values <- c(disp_values,dispersion)
 }
 
}
```

```{r}
plot(mu_values, disp_values, pch=16, xlab="mean", ylab = "dispersion")
```

## **Determine Dispersion Levels**

We simulate a single gene for $n=500$ cells and change the multiplier of the $\sigma$ parameter. Again for the **rgamma** function, the mean is $\alpha\sigma$ and the variance is $\alpha \sigma^2$. Thus, we test different multipliers for sigma to increase the variance in the simulated dispersed genes.

```{r Simulate Gene Function}
# function to simulate a null gene and dispersed gene
sim_gene <- function(n,alpha,sigma,Li, sigma_multiplier=1){

  # Simulate a single gene with following parameters:
  # n:                number of cells
  # alpha:            alpha parameter
  # sigma:            sigma parameter
  # Li:               library size
  # sigma_multiplier: factor to increase variance
 
  # Returns expression values for single gene in n cells
  
  # initialize Y
  Y <- rep(NA,n) 
  
  # calculate latent expression using gamma distribution
  lambdaj <- rgamma(n,shape = alpha/sigma_multiplier,scale = sigma*sigma_multiplier)
  
  # for each cell use the latent expression and library size to simulate expression
  for(i in 1:n){
  
    Y[i] <- rpois(1,Li*lambdaj[i])
  }
  
  return(Y)
}
```

```{r Dispersion Histogram Low Alpha, warning=F}
set.seed(8626)
n=500
alpha = 0.5
sigma = 0.0002
Li = 8000

gene1 <- sim_gene(n,alpha,sigma,Li)
gene1.5 <- sim_gene(n,alpha,sigma,Li,1.5)
gene2 <- sim_gene(n,alpha,sigma,Li,2)
gene2.5 <- sim_gene(n,alpha,sigma,Li,2.5)
gene3 <- sim_gene(n,alpha,sigma,Li,3)

df1 = rbind(data.frame(factor='1', UMI=gene1), data.frame(factor='1.5', UMI=gene1.5), data.frame(factor='2', UMI=gene2), data.frame(factor='2.5', UMI=gene2.5), data.frame(factor='3', UMI=gene3))

group.colors <- c("red","blue","forestgreen","orange", "purple")

ggplot(df1, aes(UMI, fill=factor)) + 
  geom_histogram( alpha=1, position="dodge",binwidth=0.5) + scale_fill_manual(values=group.colors) + scale_color_manual(values=group.colors) + theme(legend.key.size = unit(0.5, 'cm'), legend.title = element_text(size=10)) + theme_bw() + xlim(-0.5, 10) + ggtitle("Histogram with Varying Dispersion for Low Alpha") 

```

```{r Dispersion Histogram High Alpha, warning=F}
set.seed(8626)
n=500
alpha = 5
sigma = 0.0002
Li = 8000

gene1 <- sim_gene(n,alpha,sigma,Li)
gene1.5 <- sim_gene(n,alpha,sigma,Li,1.5)
gene2 <- sim_gene(n,alpha,sigma,Li,2)
gene2.5 <- sim_gene(n,alpha,sigma,Li,2.5)
gene3 <- sim_gene(n,alpha,sigma,Li,3)

df1 = rbind(data.frame(factor='1', UMI=gene1), data.frame(factor='1.5', UMI=gene1.5), data.frame(factor='2', UMI=gene2), data.frame(factor='2.5', UMI=gene2.5), data.frame(factor='3', UMI=gene3))

group.colors <- c("red","blue","forestgreen","orange", "purple")

ggplot(df1, aes(UMI, fill=factor)) + 
  geom_histogram( alpha=1, position="dodge",binwidth=1) + scale_fill_manual(values=group.colors) + scale_color_manual(values=group.colors) + theme(legend.key.size = unit(0.5, 'cm'), legend.title = element_text(size=10)) + theme_bw() + ggtitle("Histogram with Varying Dispersion for High Alpha") + xlim(-0.5, 40) 

```

```{r, eval=F, include=F}
hist(cardiomyocytes_expression_data_filtered[,which.max(mean_relative_expression)], breaks=20)
```

## **Simulating for Bins of Mean Expression**

We have broken down the range of mean expression into 100 bins. For each bin we will simulate 100 genes. 5% of those genes will have $\sigma$ multiplied by a factor of 2. This will yield 10,000 simulated genes with 5% of genes being significantly dispersed.

```{r Bins of Mean Expression}
# calculate alpha given mean expression and fixed sigma
calc_alpha <- function(mu, sigma){
  alpha = mu/sigma
  return(alpha)
}


# Function to simulate genes within a bin of mean expression
sim_bin <- function(n,p,sigma,sigma_multiplier,Li,mean_expr_lwr,mean_expr_upr){
  
  # Simulate all genes with following parameters:
  # n:                number of cells
  # p:                number of genes
  # sigma:            sigma parameter
  # sigma_multiplier: factor to increase variance
  # Li:               library size
  # mean_expr_lwr:    lower bound of mean expression window
  # mean_expr_upr:    upper bound of mean expression window
 
  # Returns matrix of expression for n cells and p genes. 
  # Returns vector of index values for simulated dispersed genes.
  
  # initialize Y for bin of expression
  Y_bin <- matrix(NA,nrow=n,ncol=p)
  
  # breakdown expression range into p values
  bin_expression <- seq(mean_expr_lwr,mean_expr_upr,length.out=p)
  
  # randomly select p expression means
  bin_sim_idx <- sample.int(p, p, replace = TRUE)
  # randomly select 5% to be significantly dispersed
  bin_disp_idx <- sample.int(p, 0.05*p, replace = FALSE)
  # get expression means
  sim_expression_values <- bin_expression[bin_sim_idx]
  
  # simulate genes for each expression mean
  for(i in 1:p){
    
    # get expression mean
    mu <- sim_expression_values[i]
    # calculate alpha for fixed sigma based on expression mean
    alpha <- calc_alpha(mu,sigma)
    
    # for dispersed genes multiply sigma by factor
    if(i %in% bin_disp_idx){
      Y_bin[,i] <- sim_gene(n,alpha,sigma,Li,sigma_multiplier)
    }
    else{
      Y_bin[,i] <- sim_gene(n,alpha,sigma,Li)
    }
  }
  
  return(list("Y_bin"=Y_bin, "disp_idx"=bin_disp_idx))
}

sim_Y <- function(n,p,sigma,sigma_multiplier,Li,mean_expr_lwr,mean_expr_upr){
  Y <- c()
  disp_idx <- c()
  for(i in 1:100){
    
    mean_expr_lwr <- mean_intervals[i]
    mean_expr_upr <- mean_intervals[i+1]
    
    gene_sim <- sim_bin(n,p,sigma,sigma_multiplier,Li,mean_expr_lwr,mean_expr_upr)
    Y_bin <- gene_sim$Y_bin
    bin_disp_idx <- gene_sim$disp_idx + (i-1)*100
    
    Y <- cbind(Y,Y_bin)
    disp_idx <- c(disp_idx,bin_disp_idx)
  }
  return(list("Y"=Y,"disp_idx"=disp_idx))
}


cpm_norm <- function(Y){
  
  require(scTenifoldNet)
  Y_cpm_normalized <- t(cpmNormalization(t(Y)))
  Y_log_cpm_normalized <- log(t(cpmNormalization(t(Y))))
  
  Y_cv <- apply(Y_cpm_normalized, 2, sd)/apply(Y_cpm_normalized, 2, mean)
  Y_mean <- apply(Y_cpm_normalized, 2, mean)
  Y_cv_log <- apply(Y_log_cpm_normalized, 2, sd)/apply(Y_log_cpm_normalized, 2, mean)
  Y_mean_log <- apply(Y_log_cpm_normalized, 2, mean)
  
  return(list("Y_cpm_normalized"=Y_cpm_normalized, "Y_log_cpm_normalized" = Y_log_cpm_normalized, "Y_cv" = Y_cv, "Y_mean" = Y_mean, "Y_cv_log"=Y_cv_log, "Y_mean_log" = Y_mean_log))
}

```

We simulate applying different factors to amplify the variance.

```{r}
#### Simulate Y matrix for all genes
# Parameters
n=500
p=100
sigma = 0.0002
Li = 8000

Y_1.25 <- sim_Y(n,p,sigma,1.25,Li,mean_expr_lwr,mean_expr_upr)
Y_1.5 <- sim_Y(n,p,sigma,1.5,Li,mean_expr_lwr,mean_expr_upr)
Y_1.75 <- sim_Y(n,p,sigma,1.75,Li,mean_expr_lwr,mean_expr_upr)
Y_2 <- sim_Y(n,p,sigma,2,Li,mean_expr_lwr,mean_expr_upr)

```

Perform normalization on data.

```{r}
Y_1.25_cpm <- cpm_norm(Y_1.25$Y)
Y_1.5_cpm <- cpm_norm(Y_1.5$Y)
Y_1.75_cpm <- cpm_norm(Y_1.75$Y)
Y_2_cpm <- cpm_norm(Y_2$Y)


Y_1.25_cv <- apply(Y_1.25$Y, 2, sd)/apply(Y_1.25$Y, 2, mean)
Y_1.25_mean <- apply(Y_1.25$Y, 2, mean)

Y_1.5_cv <- apply(Y_1.5$Y, 2, sd)/apply(Y_1.5$Y, 2, mean)
Y_1.5_mean <- apply(Y_1.5$Y, 2, mean)

Y_1.75_cv <- apply(Y_1.75$Y, 2, sd)/apply(Y_1.75$Y, 2, mean)
Y_1.75_mean <- apply(Y_1.75$Y, 2, mean)

Y_2_cv <- apply(Y_2$Y, 2, sd)/apply(Y_2$Y, 2, mean)
Y_2_mean <- apply(Y_2$Y, 2, mean)
```

```{r, eval=F, include=F}
par(mfrow = c(2, 2))

plot(log(Y_1.25_mean),Y_1.25_cv, pch=16, cex=0.5 ,main = "Factor: 1.25", xlab="log(mean)", ylab="CV")
points(log(Y_1.25_mean[Y_1.25$disp_idx]),Y_1.25_cv[Y_1.25$disp_idx],pch=16,col="red",cex=0.5)

plot(log(Y_1.5_mean),Y_1.5_cv, pch=16, cex=0.5 ,main = "Factor: 1.5", xlab="log(mean)", ylab="CV")
points(log(Y_1.5_mean[Y_1.5$disp_idx]),Y_1.5_cv[Y_1.5$disp_idx],pch=16,col="red",cex=0.5)

plot(log(Y_1.75_mean),Y_1.75_cv, pch=16, cex=0.5 ,main = "Factor: 1.75", xlab="log(mean)", ylab="CV")
points(log(Y_1.75_mean[Y_1.75$disp_idx]),Y_1.75_cv[Y_1.75$disp_idx],pch=16,col="red",cex=0.5)

plot(log(Y_2_mean),Y_2_cv, pch=16, cex=0.5 ,main = "Factor: 2", xlab="log(mean)", ylab="CV")
points(log(Y_2_mean[Y_2$disp_idx]),Y_2_cv[Y_2$disp_idx],pch=16,col="red",cex=0.5)
mtext("No Normalization", side = 3, line = - 1, outer = TRUE)
```

We compare CPM vs log(CPM) normalization. We see the increase effect of applying the factor to the variance.

```{r}
par(mfrow = c(2, 2))

plot(log(Y_1.25_cpm$Y_mean),Y_1.25_cpm$Y_cv, pch=16, cex=0.5 ,main = "Factor: 1.25", xlab="log(mean)", ylab="CV")
points(log(Y_1.25_cpm$Y_mean[Y_1.25$disp_idx]),Y_1.25_cpm$Y_cv[Y_1.25$disp_idx],pch=16,col="red",cex=0.5)

plot(log(Y_1.5_cpm$Y_mean),Y_1.5_cpm$Y_cv, pch=16, cex=0.5 ,main = "Factor: 1.5", xlab="log(mean)", ylab="CV")
points(log(Y_1.5_cpm$Y_mean[Y_1.5$disp_idx]),Y_1.5_cpm$Y_cv[Y_1.5$disp_idx],pch=16,col="red",cex=0.5)

plot(log(Y_1.75_cpm$Y_mean),Y_1.75_cpm$Y_cv, pch=16, cex=0.5 ,main = "Factor: 1.75", xlab="log(mean)", ylab="CV")
points(log(Y_1.75_cpm$Y_mean[Y_1.75$disp_idx]),Y_1.75_cpm$Y_cv[Y_1.75$disp_idx],pch=16,col="red",cex=0.5)

plot(log(Y_2_cpm$Y_mean),Y_2_cpm$Y_cv, pch=16, cex=0.5 ,main = "Factor: 2", xlab="log(mean)", ylab="CV")
points(log(Y_2_cpm$Y_mean[Y_2$disp_idx]),Y_2_cpm$Y_cv[Y_2$disp_idx],pch=16,col="red",cex=0.5)
mtext("CPM Normalized", side = 3, line = - 1, outer = TRUE)
```

```{r}
par(mfrow = c(2, 2))

plot(Y_1.25_cpm$Y_mean_log,Y_1.25_cpm$Y_cv_log, pch=16, cex=0.5 ,main = "Factor: 1.25", xlab="log(mean)", ylab="CV")
points(Y_1.25_cpm$Y_mean_log[Y_1.25$disp_idx],Y_1.25_cpm$Y_cv_log[Y_1.25$disp_idx],pch=16,col="red",cex=0.5)

plot(Y_1.5_cpm$Y_mean_log,Y_1.5_cpm$Y_cv_log, pch=16, cex=0.5 ,main = "Factor: 1.5", xlab="log(mean)", ylab="CV")
points(Y_1.5_cpm$Y_mean_log[Y_1.5$disp_idx],Y_1.5_cpm$Y_cv_log[Y_1.5$disp_idx],pch=16,col="red",cex=0.5)

plot(Y_1.75_cpm$Y_mean_log,Y_1.75_cpm$Y_cv_log, pch=16, cex=0.5 ,main = "Factor: 1.75", xlab="log(mean)", ylab="CV")
points(Y_1.75_cpm$Y_mean_log[Y_1.75$disp_idx],Y_1.75_cpm$Y_cv_log[Y_1.75$disp_idx],pch=16,col="red",cex=0.5)

plot(Y_2_cpm$Y_mean_log,Y_2_cpm$Y_cv_log, pch=16, cex=0.5 ,main = "Factor: 2", xlab="log(mean)", ylab="CV")
points(Y_2_cpm$Y_mean_log[Y_2$disp_idx],Y_2_cpm$Y_cv_log[Y_2$disp_idx],pch=16,col="red",cex=0.5)

mtext("Log CPM Normalized", side = 3, line = - 1, outer = TRUE)

```

```{r Single Gene Example, include=F,eval=F}
# We estimate the mean and variance from the relative expression to calculate estimates for $\alpha = mean^2/variance$ and $\sigma = variance/mean$.

alphas <- mean_relative_expression^2/var_relative_expression
sigmas <- var_relative_expression/mean_relative_expression


# We use the estimates for $\alpha$ and $\sigma$ to simulate the $\lambda_j \sim Gamma(\alpha,\sigma)$. The simulated $\lambda_j$ and library size $L_i$ are used to simulate $y_{ij} \sim Pois(L_i\lambda_j)$. We do this first for 1 example gene.


set.seed(8626)
n=500
gamma_dist <- rgamma(n,shape = alphas[1],scale = sigmas[1])
library_size_lambda <- library_sizes[1]*gamma_dist

yi <- c()
for(i in 1:n){
  yi <- c(yi,rpois(1,library_size_lambda[1]))
}



# We compare the histograms of UMI in 1 real versus simulated gene.



df1 = rbind(data.frame(grp='real data', UMI=cardiomyocytes_expression_data_filtered[,1]), data.frame(grp='simulated', UMI=yi))
group.colors <- c("red","blue")
ggplot(df1, aes(UMI, fill=grp)) + 
  geom_histogram(color='black', alpha=1, position="dodge",binwidth=0.5) + scale_fill_manual(values=group.colors)
```
